//
//  OperatingSystemMemoryManagement.m
//  Runtime
//
//  Created by tigerfly on 2021/1/7.
//  Copyright © 2021 tiger fly. All rights reserved.
//

#import "OperatingSystemMemoryManagement.h"

@interface OperatingSystemMemoryManagement ()

@end

@implementation OperatingSystemMemoryManagement

- (void)viewDidLoad {
    [super viewDidLoad];
    // Do any additional setup after loading the view.
    
    /*
     Memory management is the functionality of an operating system
     which handles or manages primary memory and moves processes
     back and forth between main memory and disk during execution.
     Memory management keeps track of each and every memory location,
     regardless of either it is allocated to some process or it is
     free. It checks how much memory is to be allocated to processes.
     It decides which process will get memory at what time. It tracks
     whenever some memory get freed or unallocated and correspondingly
     it updates the status.
     
     This tutorial will teach you basic concepts related to Memory
     Management.
     */
    
    
    /**
     Process Address Space
     
     The process address space is the set of logical addresses that
     a process references in its code. For example, when 32-bit addressing
     is in use, addresses can range from 0 to 0x7fffffff; that is, 2^32
     possible numbers, for a total theoretical size of 2 gigabytes.
     
     The operating system takes care of mapping the logical addresses to
     physical addresses at the time of memory allocation to the program.
     There are three types of addresses used in a program before and
     after memory is allocated -
     
     Memory Addresses & Description
     1. Symbolic addresses
        The addresses used in a source code. The variable names, constants,
        instruction labels are the basic elements of the symbolic address
        space.
     
     2. Relative addresses
        At the time of compilation, a compiler converts symbolic addresses
        into relative addresses.
     
     3. Physical addresses
        The loader generates these addresses at the time when a program
        is loaded into main memory.

     Virtual and Physical addresses are the same in compile-time and
     load-time address-binding schemes. Virtual and physical addresses
     differ in execution-time address-binding scheme.
     
     The set of all logical addresses generated by a program is referred
     to as a logical address space. The set of all physical addresses
     corresponding to these logical addresses is referred to as a physical
     addresses space.
     
     The runtime mapping from virtual to physical address is done by the
     memory management unit(MMU) which is a hardware device. MMU uses
     following mechanism to convert virtual address to physical address.
     
        •   The value in the base register is added to every address
            generated by a user process, which is treated as offset
            at the time it is sent to memory. For example, if the
            base register value is 10000, then an attempt by the user
            to use address location 100 will be dynamically reallocated
            to location 10100.
        •   The user program deals with virtual addresses; it never
            sees the real physical addresses.

     
     */
    
    
    
    
    
}

/*
#pragma mark - Navigation

// In a storyboard-based application, you will often want to do a little preparation before navigation
- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender {
    // Get the new view controller using [segue destinationViewController].
    // Pass the selected object to the new view controller.
}
*/

@end
